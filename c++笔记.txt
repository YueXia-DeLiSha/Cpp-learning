温馨提示一定要检查输入法是否为英文 g++编译cpp文件命令：g++ cpp文件名 -o 想要的名称.exe
cout输出cin输入
 main是一个程序入口每个程序都必须有这么一个函数有且仅有一个 main是主函数，只能有一个，其他是辅函数，可以自己命名
1.2 注释作用：在代码中加一些说明和解释，方便自己和其他程序员阅读代码
 单行注释//注释内容 
通常放在一行代码的上方，或者一条语句的末尾，对该代码说明
多行注释/*注释内容*/ 
通常放在一段代码的上方，对该段代码整体说明
（提示：编译器在编译代码时，会忽略注释内容）
1.3 变量
变量存在的意义：方便我们管理内存空间 内存地址编号一般为16进制数 
作用：给一段指定内存空间起名，方便操作这段内存
语法：数据类型 变量名 = 变量初始值；
1.4 常量
作用：用于记录内存中不可更改的数据
C++定义常量两种方式
1.#define 宏常量：#define 常量名 常量值
（通常在文件上方定义，表示一个常量）
2.const修饰的变量 const 数据类型 常量名 = 常量值
（通常在变量定义前加关键字const，修饰该变量为常量，不可修改）
1.5 关键字
作用：关键字是C++中预先保留的单词
（在定义变量和常量时候，不要用关键字）
C++关键字如下
asm do if return typedef auto double inline short typeid bool dynamic_cast int signed typename break else long sizeof union case enum mutable static unsigned catch
explicit namespace static_cast using char export new struct virtual class extern operator switch void const false private template volatile const_cast float protected this 
wchar_t continue for public throw while default friend register true delete goto reinterpret_cast try

在命名变量和常量时，不要用c++关键字否则会起歧义
1.6 标识符命名规则
作用：c++规定给标识符（变量 常量）命名时，有一套自己的规则 1.标识符不能为关键字 2.标识符只能由字母数字下划线组成 
3.第一个字符必须为字母或下划线 标识符中字母区分大小写   （建议：给标识符命名时争取做到见名知意的效果方便自己和他人阅读）
2 数据类型 C++规定在创建一个变量和常量时，必须指出相应的数据类型，否则无法给变量分配内存。
  数据类型存在意义：给变量分配合适的内存空间
2.1 数据类型-整型
作用：整型变量表示的是整型类型的数据
C++中能够表示整型的类型有一下几种方式，区别在于所占用内存空间不同：
数据类型	              占用空间	                                                                                                  取值范围
short(短整型)	2字节	                                                                                            (-2^15 ~ 2^15-1)    (-32768~32767)
int(整型)	                4字节	                                                                                            (-2^31 ~ 2^31-1)    (-2147483648~21474836747)
long(长整形)	Windows为4字节，Linux为4字节(32位)，8字节(64位)	                            (-2^31 ~ 2^31-1)    (-2147483648~21474836747)
long long(长长整形)	8字节	                                                                                            (-2^63 ~ 2^63-1)  （-9,223,372,036,854,775,808~9,223,372,036,854,775,807）
超过取值上限就会回到取值下限，没有特殊需求一般用int可以了。
2.2 sizeof关键字
作用：利用sizeof关键字可以统计数据类型所占内存大小
语法：sizeof( 数据类型 / 变量)
整型结论：short<int<=log<=long long
2.3 数据类型-实型（浮点型）
作用：用于表示小数
浮点变量分为两种：
1.单精度float
2.双精度double
两者区别在于表示的有效数字范围不同。
数据类型          占用空间         有效数字范围
float                 4字节               7位有效数字
double              8字节              15~16位有效数字

float类型后面一般在数字后面加一个f   不加f默认认为是double
默认情况下 输出一个小数，会显示出6位有效数字
科学计数法：3e2 =3*10^2    3e-2=3*10^-2=3*0.1^2 
 e后面是正数代表是10^n次方   如果是负数就是0.1^n次方或者10的负次方
例如3e2 =3*10^2                         3e-2=3*10^-2=3*0.1^2   
2.4 数据类型-字符型
 作用：字符型变量用来显示单个字符
语法：char ch = ‘a’
注意1：在显示字符型时，用单引号将字符括起来，不要用双引号
注意2：单引号内只能有一个字符，不可以是字符串
C和C++中字符型变量只占用一个字节。
字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入存储单元
//3.字符型变量常见错误
//char ch2 = "b"; 创建字符型变量时候，要用单引号
// char ch3 = 'ab'; 创建字符型变量时候，单引号内只能有一个字符
//4.字符型变量对应ASCII编码
char ch = 'a'
 cout << (int)ch << endl;//查看a对应的ASCII码
可以直接用ASCII直接给字符型变量赋值
//a-97
//A-65
ASCII码大致由以下两部分组成：
ASCII非打印控制字符：ASCII表上的数据0-31分配给了控制字符，用于控制像打印机等一些外围设备。
ASCII打印字符：数字32-126分配给了能在键盘找到的字符，当查看或打印文档时5就会出现。
2.5 数据类型-转义字符
作用：用于表示一些不能显示出来的ASCII字符
现阶段常用的转义字符有：\n    \\  \t
转义字符	意义	                                                                 ASCLL码值(十进制)
\a	警报(BEL)	                                                                   007
\b	退格(BS) ，将当前位置移到前一列	                   008
\f	换页(FF)，将当前位置移到下页开头	                   012
\n	换行(LF) ，将当前位置移到下一行开头	                   010
\r	回车(CR) ，将当前位置移到本行开头	                   013
\t	水平制表(HT) （占8个空位用于填充）	                   009
\v	垂直制表(VT)	                                                   011
\'	代表一个单引号	                                                   039
\"	代表一个双引号字符	                                                   034
\\	代表一个反斜线字符'''	                                                   092
\?	代表一个问号	                                                   063
\0	空字符(NUL)	                                                   000
\ddd	8进制转义字符，d范围0-7	                                   三位八进制
\xhh	16进制转义字符，十六进制所代表的任意字符	   三位十六进制

\t    作用可以整齐输出数据
2.6 数据类型-字符串型
作用：表示一串字符
两种风格：
C风格字符串：char 变量名[ ] = "字符串值"   注意：C风格要用双括号括起来 注意事项2 等号后面要用双引号 包含起来字符串
C++风格字符串：string 变量名 = "字符串值"
2.7数据类型-布尔类型 bool
作用：布尔数据类型代表真或假 bool类型 只要是非0的值都代表真
bool类型只有两个值：
true  ---真 （本质是1）
false ---假 （本质是0）
bool类型占1个字节大小
本质上1表示真 0表示假
2.8 数据类型-数据的输入
作用：用于从键盘获取数据
关键字：cin
语法：cin >> 变量
bool类型 只要是非0的值都代表真
3.0 运算符
作用：用于执行代码的运算 本章主要讲解以下几类的运算符：
算术运算符  作用：处理四则运算
赋值运算符  作用：用于将表达式的赋值给变量
比较运算符  作用：用于表达式的比较，并返回一个真值或假值
逻辑运算符  作用：用于根据表达式的值返回真值或假值
3.1 算术运算符
运算符                                 术语                                    示例                                                   结果
+                                          正号                                    +3                                                      3
-                                          负号                                      -3                                                       -3
+                                           加                                     10+5                                                   15
-                                            减                                     10-5                                                      5
*                                             乘                                    10*5                                                     50
/                                             除                                    10/5                                                      2
%                                      取模（取余）                          10%3                                                     1
++                                    前置递增                                 a=2;b=++a                                          a=3;b=3
++                                    后置递增                                 a=2;b=a++                                          a=3;b=2
--                                      前置递增                                 a=2;b=--a                                            a=1;b=1
--                                      前置递减                                 a=2;b=a--                                            a=1;b=2
3.1.1 加减乘除
加减在前，先加减再用，加减在后，用完再加减
3.1.2 取余
取余运算符 % 只能用于整数    取余运算本质就是除法取余数
两个数相除，除数不可以为0，所以做不了取余运算
两个小数是不可以做取余运算的
3.1.3 递增递减
前置递增 先让变量加1再进行表达式运算 (a+1)*10
后置递增 先进行表达式运算再让变量加1 (a)*10+1
前置递减 先让变量减1再进行表达式运算 (a-1)*10
后置递减 先进行表达式运算再让变量减1 (a)*10-1
3.2 赋值运算符
作用：用于将表达式的值赋给变量
赋值运算符 = 将右侧的值赋给左侧的变量
运算符                                 术语                                    示例                                                   结果
=                                      赋值                                     a=2;b=3                                          a=2;b=3
+=                                      加等于                                  a=0;a+=2;                                         a=2;
-=                                      减等于                                  a=5;a-=3;                                         a=2;
*=                                      乘等于                                  a=2;a*=2;                                         a=4;	
/=                                      除等于                                  a=4;a/=2;                                         a=2;
%=                                      取余等于                                a=3;a%=2;                                         a=1;
+= 就是让变量先加再赋值       a += 2; // a = a + 2 ;
-= 就是让变量先减再赋值        a -= 2; // a = a - 2 ;
*= 就是让变量先乘再赋值        a *= 2; // a = a * 2 ;
/= 就是让变量先除再赋值      a /= 2; // a = a / 2 ;
%= 就是让变量先取余再赋值    a %= 2; // a = a % 2 ;
3.2比较运算符
作用：用于表达式的比较，并返回一个真值或假值
运算符                                 术语                                    示例                                                   结果
==                                      等于                                     5==5                                                  true（1）
!=                                      不等于                                  5!=5                                                  false （0）
<                                       小于                                     5<5                                                   false （0）
>                                       大于                                     5>5                                                   false （0）
<=                                      小于等于                                 5<=5                                                  true （1）
>=                                      大于等于                                 5>=5                                                  true （1）
运算时需要加括号示例 (a < b) 让先做运算
3.3逻辑运算符
作用：用于根据表达式的值返回真值或假值
运算符                                 术语                                    示例                                                   结果
&&                                      与                                   true&&false                                           false
||                                      或                                   true||false                                           true
!                                       非                                   !true                                                  false
与 &&：两边都为真才是真，只要有一个假就是假   示例 开关串联开关
或 ||：两边都为假才是假，只要有一个真就是真   示例 开关并联开关
非 !：把真变成假，把假变成真  取反
与或非优先级不同，与的优先级高于或，高于非  与>或>非
在c++中除了0都是真
4 程序流结构
C/C++支持以下最基本的三种程序运行结构：
顺序结构：程序按顺序执行，不发生跳转。
选择结构：根据判断条件是否成立，有选择的执行相应功能。
循环结构：根据判断条件是否成立，循环执行某段代码。
4.1 选择结构
4.1.1 if语句
作用执行满足条件的语句
if语句的三种形式
单行格式的if语句      if(条件){}  条件为真执行大括号内容   注意事项，if条件后面不要加分号(；)
多行格式的if语句      if(条件){条件满足执行的语句}else{条件不满足执行的语句}  
多条件的if语句        if(条件1){条件1满足执行的语句}else if(条件2){条件2满足执行的语句}else .....else{都不满足的执行的语句}
还有一种格式，嵌套if语句
嵌套if语句：在if语句中嵌套使用if语句，达到更准确的条件判断 
嵌套if语句示例代码：
int score = 0;
cout << "输入你的高考分数：" << endl;
cin >> score;
//2.显示用户输入的分数
cout << "你输入的分数是：" << score << endl;
//3.判断
if (score > 600) {
	cout << "恭喜你考上一本大学" << endl;
	if (score > 700) {
		cout << "恭喜你考上了北京大学" << endl;
	}
	else if (score > 650) {
		cout << "恭喜你考上了清华大学" << endl;
	}
	else if (score > 600) {
		cout << "恭喜你考上了人民大学" << endl;
	}
}
else if (score > 500) {
	cout << "恭喜你考上了二本大学" << endl;
}
else if (score > 400) {
	cout << "恭喜你考上了三本大学" << endl;
}
else {
	cout << "未考上本科" << endl;
}
4.1.2 三目运算符
作用：通过三目运算符实现简单的判断
语法：表达式1 ? 表达式2 ：表达式3
解释：如果表达式1的值为真，执行表达式2，并返回表达式2的结果；
如果表达式1的值为假，执行表达式3，并返回表达式3的结果。
在C++中，三目运算符返回的是变量，可以继续赋值
4.1.3 switch语句
作用：实现多条件分支判断
语法：
switch(表达式){
case 结果1: 执行语句；break；
case 结果2: 执行语句；break；
...
default: 执行语句；break；
}
注意事项：
表达式的结果必须是整型或字符型
case里放的是要和表达式结果对比的值
结果值可以是常量或者常量表达式
break可以省略，但是会带来代码逻辑错误，不建议省略
break; //退出当前分支
case里没有break，代码会向下执行
//if和switch的区别
//switch缺点，表达式的结果必须是整型或者字符型，不可以是一个区间
//switch优点，结构清晰，执行效率高
//if优点，表达式的结果可以是任意类型，可以是区间
//if缺点，执行效率相对低，结构没有switch清晰
4.2 循环结构
4.2.1 while循环
作用：满足循环条件，执行循环语句
语法：while(循环条件) 循环语句;
解释：只要循环条件的结果为真，就执行循环语句
注意事项：循环一定要有退出的条件，否则就是死循环
rand是一个生成随机数的函数
示例：
rand()%100    //生成一个0-99的随机数
srand随机数种子函数
示例：srand((unsigned int)time(NULL));
srand 用于初始化随机数生成器。它接受一个种子值，并根据这个种子值生成一系列伪随机数。
time(NULL) 返回的是一个 time_t 类型的值，表示当前时间的时间戳。将这个时间戳作为种子值传递给 srand 函数，可以确保每次运行程序时，随机数生成器都会从一个不同的起始点开始，从而生成不同的随机数序列。
(unsigned int) 是一个类型转换操作，将 time_t 类型的值转换为 unsigned int 类型。这种转换通常是为了确保传递给 srand 函数的值是无符号整数。
srand 用于初始化随机数生成器。它接受一个种子值，并根据这个种子值生成一系列伪随机数。
4.2.2 do...while循环
作用：满足循环条件，执行循环语句
语法：do{循环语句} while(循环条件);
注意：与while循环不同的是，do...while循环会先执行循环语句，再判断循环条件，只要循环条件的结果为真，就会重复执行循环语句。
解释：do...while循环会先执行循环语句，再判断循环条件，只要循环条件的结果为真，就会重复执行循环语句。
4.2.3 水仙花
获取个位数：num % 10 取余 对数字取模于10就可以拿到个位数
获取十位数：num / 10 % 10 整除除以10再取余就可以拿到十位数
获取百位数：num / 100  整除除以100就可以拿到百位数
4.2.4 for循环
作用：满足循环条件，执行循环语句
语法：for(起始表达式; 循环条件; 循环后操作)
循环语句;
解释：起始表达式先执行一次，然后判断循环条件，如果条件为真，执行循环语句，然后执行循环后操作，再判断循环条件，如果条件为真，继续执行循环语句，直到循环条件为假，退出循环。
for循环的执行顺序：
1. 执行起始表达式
2. 判断循环条件，如果为真，执行循环语句，然后执行循环后操作，再判断循环条件，如果为真，继续执行循环语句，直到循环条件为假，退出循环。
3. 如果循环条件为假，直接退出循环。
4.2.5 嵌套循环
作用：在循环中嵌套使用循环，可以完成一些复杂的重复性操作
语法：外层循环控制行数，内层循环控制列数
示例：
//外层循环
for (int i = 0; i < 10; i++) {
	//内层循环
	for (int j = 0; j < 10; j++) {
		cout << "* ";
	}
	cout << endl;
}
4.3 跳转语句 
4.3.1 break语句
作用：用于跳出选择和循环结构
break使用时机：
出现在switch语句中，作用是终止case并跳出switch	
出现在循环语句中，作用是跳出当前循环语句
出现在嵌套循环中，跳出最近的内层循环
4.3.2 continue 语句
作用：跳过本次循环中余下的代码，直接进行下一次循环
continue使用时机：
出现在循环语句中，作用是跳过本次循环中余下的代码，直接进行下一次循环
4.3.3 goto语句
作用：可以无条件跳转到程序中指定的行
语法：goto 标记;
解释：goto语句可以无条件地跳转到程序中指定的行，标记是一个标识符，后面跟一个冒号。 
示例：
goto FLAG;
cout << "1" << endl;
cout << "2" << endl;
cout << "3" << endl;
FLAG:
cout << "4" << endl;
cout << "5" << endl;
注意事项：
滥用goto语句会导致代码结构混乱，可读性差，建议谨慎使用。
goto语句通常用于处理特殊情况，例如错误处理或跳出多层循环。
goto语句的跳转范围是整个函数，因此需要谨慎使用，以避免跳转到未定义的代码行。
5 数组
5.1 数组定义
作用：用来存储一组相同类型的数据
语法：数据类型 数组名[元素个数];
特点1：数组中存放的数据类型必须统一
特点2：数组是由连续的内存地址组成的
特点3：数组名是数组的标识符，数组名表示整个数组，数组名中存储的是数组首元素的地址
特点4：数组中下标是从0开始的
5.2.1 一维数组
一维数组定义方式
方式1：数据类型 数组名[数组长度];
方式2：数据类型 数组名[数组长度] = {值1，值2...};
方式3：数据类型 数组名[] = {值1，值2...};
5.2.2 一维数组数组名
一维数组名称的用途：
1. 可以统计整个数组在内存中的长度
2. 可以获取数组中某个元素的地址
示例：
int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
cout << "整个数组所占内存空间为：" << sizeof(arr) << endl;//整个数组所占内存空间为：40
cout << "数组第一个元素所占内存空间为：" << sizeof(arr[0]) << endl; //数组第一个元素所占内存空间为：4
cout << "数组名arr的值为：" << arr << endl; //数组名arr的值为：0x61feec
cout << "数组名arr的地址为：" << &arr << endl; //数组名arr的地址为：0x61feec
cout << "数组第一个元素的地址为：" << &arr[0] << endl; //数组第一个元素的地址为：0x61feec
cout << "数组第二个元素的地址为：" << &arr[1] << endl; //数组第二个元素的地址为：0x61ff00
cout << "数组第三个元素的地址为：" << &arr[2] << endl; //数组第三个元素的地址为：0x61ff04
5.2.2.1 一维数组案例-元素逆置
起始下标和结束下标位置互换
示例代码
int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
int start = 0;
int end = sizeof(arr) / sizeof(arr[0]) - 1;
while (start < end) {
	int temp = arr[start];
	arr[start] = arr[end];【

	arr[end] = temp;
	start++;
	end--;
}
for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++) {
	cout << arr[i] << endl;
}
遍历数组找到想要数据并获取下标号示例：
for(int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++) {
	if (arr[i] == 5) {
		cout << "找到了，位置在下标为：" << i << endl;
		break;
	}
}
5.2.3 冒泡排序
作用：最常用的排序算法，对数组内元素进行排序
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2.对每一对相邻元素做同样的工作，执行完毕后找到最大的元素，它会被放到数组的末尾。
3.重复以上步骤，每次比较次数-1，直到不需要比较。
sizeof(arr)/sizeof(arr[0])是计算数组的长度

for (int j =0; j < sizeof(arr)/sizeof(arr[0]) -1 - i; j++)
这里，内层循环的次数是数组长度-1再减去当前轮数i。
因为每一轮都会将当前未排序部分的最大值放到最后，所以下一轮就可以少比较一次。

比较相邻元素
从数组开头开始，逐一比较相邻的两个元素（例如 arr[0]和arr[1]）。
交换位置
如果前一个元素比后一个大（arr[j] > arr[j+1]），就交换它们的位置。
传递最大值
每一轮完整的遍历后，当前未排序部分的最大值一定会被推到末尾（就像气泡浮到水面）。
缩小范围
下一轮遍历时，忽略已排序好的末尾部分（比较次数减一），重复上述过程直到全部有序。
示例：
int arr[10] = {4,2,8,0,5,7,1,3,9,6};
// 外层循环：控制轮数（n-1轮）
for (int i = 0; i < sizeof(arr)/sizeof(arr[0]) - 1; i++) {
    // 内层循环：相邻元素两两比较（每轮减少一次比较）
    for (int j = 0; j < sizeof(arr)/sizeof(arr[0]) - 1 - i; j++) {
        if (arr[j] > arr[j + 1]) {  // 前>后？交换！
            int temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
}
for (int i = 0; i < sizeof(arr) / sizeof(arr[0]); i++) {
	cout << arr[i] << endl;
}
5.2.4 数组越界
数组下标从0开始，如果数组下标大于等于数组长度，则下标对应的元素不存在，访问不存在元素会报错
5.3 二维数组
二维数组定义方式
方式1：数据类型 数组名[行数][列数];
方式2：数据类型 数组名[行数][列数] = { {值1，值2...}，{值1，值2...}... };
方式3：数据类型 数组名[行数][列数] = { 值1，值2... };
方式4：数据类型 数组名[][列数] = { 值1，值2... };
5.3.2 二维数组数组名
二维数组名称的用途：
1. 可以统计整个数组在内存中的长度
2. 可以获取数组中某个元素的地址
示例：
int arr[2][3] = 
{ 
	{1,2,3},
	{4,5,6} 
	};
cout << "整个二维数组所占内存空间为：" << sizeof(arr) << endl; //整个二维数组所占内存空间为：24
cout << "二维数组第一行所占内存空间为：" << sizeof(arr[0]) << endl; //二维数组第一行所占内存空间为：12
cout << "二维数组第一行第一个元素所占内存空间为：" << sizeof(arr[0][0]) << endl; //二维数组第一行第一个元素所占内存空间为：4
cout << "二维数组名arr的值为：" << arr << endl; //二维数组名arr的值为：0x61feec
cout << "二维数组名arr的地址为：" << &arr << endl; //二维数组名arr的地址为：0x61feec
cout << "二维数组第一行第一个元素的地址为：" << &arr[0][0] << endl; //二维数组第一行第一个元素的地址为：0x61feec
cout << "二维数组第一行第一个元素的地址为：" << arr[0] << endl; //二维数组第一行第一个元素的地址为：0x61feec
cout << "二维数组第二行第一个元素的地址为：" << arr[1] << endl; //二维数组第二行第一个元素的地址为：0x61ff0c
遍历二维数组示例：
for (int i = 0; i < 2; i++) {
	for (int j = 0; j < 3; j++) {
		cout << arr[i][j] << " ";
	}
	cout << endl;
}
6.0 函数

6.1 概述
作用：将一段重复使用的代码封装起来，减少重复代码
一个较大的程序，一般分为若干个程序模块，每个模块实现特定的功能。
6.2 函数的定义
函数的定义一般包含五个部分：返回值类型、函数名、参数列表、函数体、返回语句。
返回值类型：指定函数返回值的类型，可以是任何数据类型，包括基本数据类型和复合数据类型。
函数名：用于标识函数，函数名应该具有描述性，以便于理解函数的功能。
参数列表：用于传递给函数的参数，参数列表可以包含零个或多个参数，每个参数由参数类型和参数名组成，参数之间用逗号分隔。
函数体：用于实现函数的具体功能，函数体可以包含任意数量的语句，包括变量声明、条件语句、循环语句等。
返回语句：用于返回函数的结果，返回语句可以包含一个表达式，表达式的值将作为函数的返回值。
语法：返回值类型 函数名(参数列表) { 函数体; 返回语句; }
6.3 函数的调用
函数的调用是指通过函数名和参数来执行函数中的代码。
函数的调用方式：
函数名(参数列表);
函数的调用时机：
当需要执行函数中的代码时，可以通过函数名和参数来调用函数。
函数的调用过程：
当调用函数时，程序会跳转到函数的定义处，执行函数体中的代码，然后返回到调用函数的地方，继续执行后续的代码。
6.4 值传递
值传递是指在调用函数时，将实际参数的值复制一份传递给函数的形式参数，函数内部对形式参数的修改不会影响到实际参数的值。
当不需要返回值时可以使用void 可以省略return
当我们做值传递时，函数形参发生改变不会影响到实参
6.5 常见形式
常见的函数定义形式有：
无参无返：函数没有参数，也没有返回值
示例：void test() { }
调用：test();
有参无返：函数有参数，没有返回值
示例：void test(int a) { }
调用：test(10);
无参有返：函数没有参数，有返回值
示例：int test() { return 10; }
调用：int num = test();
有参有返：函数有参数，有返回值
示例：int test(int a) { return a; }
调用：int num = test(10);
无类型void无法创建创建变量但可以创建函数因为无法分配内存
6.6 函数的声明
作用：告诉编译器函数名称以及如何调用函数，函数的实际主体可以单独定义。
函数声明语法：返回值类型 函数名(参数列表);
函数声明的作用：
1. 告诉编译器函数的名称和参数列表，以便于编译器进行语法检查。
2. 告诉编译器函数的返回值类型，以便于编译器进行类型检查。
声明可以有多次但是函数的定义只能有一次
6.7函数的分文件编写
作用：让代码结构更加清晰
函数分文件编写一般有4个步骤：
1. 创建后缀名为.h的头文件，用于声明函数。语法：函数返回值类型 函数名(参数列表);
2. 创建后缀名为.cpp的源文件，用于定义函数。语法：函数返回值类型 函数名(参数列表) { 函数体; }
3. 在需要调用函数的源文件中包含头文件。
4. 在需要调用函数的源文件中调用函数。
调用方法：#include"头文件名" 在源文件中也要包含头文件
在源文件中包含头文件是为了告诉编译器函数的声明，以便于编译器进行语法检查。
7 指针
7.1 指针的基本概念
指针是一个变量，其值为另一个变量的地址，即，指针变量的值存放的是另一个变量的地址。
指针变量：指针变量是一种特殊的变量，其值是一个内存地址。
指针常量：指针常量是一个固定的内存地址，不能被修改。
指针数组：指针数组是一个数组，其元素是指针变量。
作用：可以通过指针间接访问内存中的数据，实现动态内存分配和内存管理。
内存编号一般从0开始记录，一般用16进制数字表示
可以用指针变量保存地址
7.2 指针的定义和使用
指针的定义语法：数据类型 *指针变量名;
指针的使用语法：指针变量名 = &变量名; 
指针的访问语法：*指针变量名 = 变量值;
指针的解引用语法：变量值 = *指针变量名;
指针的->访问语法：变量值 = 指针变量名->成员名;
指针的[]访问语法：变量值 = 指针变量名[下标];
指针的++和--操作：指针变量名++; 指针变量名--;
指针的加减操作：指针变量名 += n; 指针变量名 -= n;
(int *)表示指向int类型的指针包含两个信息：
1. 指针的类型：int *表示指向int类型的指针。
2. 指针的大小：int *表示指针的大小为4个字节。
示例：
int num =10;
int *p = &num; //指针p指向num的地址
void *voidp = &num; //void *表示指向任意类型的指针，voidp指向num的地址
int *intp = (int*)voidp; //将void *类型的指针转换为int *类型的指针

指针前面加*表示解引用，即获取指针所指向的内存地址中的数据。
7.3 指针所占内存空间
指针类型决定了指针所指向的内存空间的大小。
指针类型	占用内存空间
char	1个字节
short	2个字节
int	4个字节
long	4个字节
long long	8个字节
float	4个字节
double	8个字节
指针类型决定了指针所指向的内存空间的大小，不同类型的指针所占用的内存空间大小不同。
7.4 空指针和野指针
空指针：指针变量指向内存中编号为0的空间 作用：初始化指针变量 空指针指向的内存不可访问 0~255之间的内存编号是系统内存编号，因此不能访问
野指针：指针变量指向的内存空间地址不合法
空指针和野指针的区别：
空指针指向的内存空间是合法的，但是该内存空间没有分配任何数据。
野指针指向的内存空间是非法的，该内存空间可能已经被分配给其他数据，或者该内存空间不存在。
空指针和野指针的危害：
空指针和野指针都可能导致程序崩溃，因为它们指向的内存空间可能已经被其他数据占用，或者该内存空间不存在。
7.5 const修饰指针
const修饰指针有三种情况：
const修饰常量 示例：
int const *p = &a; //指针指向的值不能修改
*p = 100; //错误，不能通过指针修改指向的值
p = &b; //正确，指针可以指向其他变量
int * const p = &a; //指针指向的地址不能修改
p = &b; //错误，不能通过指针修改指向的地址

解释：指针指向的值为常量不可修改，可以改变指针指向的地址
const修饰指针  示例：
int a = 10;
int b = 20;
int * const p = &a; //指针指向的值不能修改
*p = 100; //正确，可以通过指针修改指向的值
p = &b; //错误，不能通过指针修改指向的地址
解释: 指针指向的地址不可修改，可以改变指针指向的值

const修饰指针常量----修饰指针指向的地址和值  示例：
int a = 10;
int b = 20;
const int * const p = &a; //指针指向的地址和值都不能修改
*p = 100; //错误，不能通过指针修改指向的值
p = &b; //错误，不能通过指针修改指向的地址
解释：指针指向的地址和值都不能修改
7.6 指针和数组
利用指针访问数组元素
数组名在大多数情况下可以当作指针来使用，因此可以通过指针来访问数组元素。可以通过指针变量名来访问数组元素。指针变量名[下标] 也可以通过指针变量名加减来访问数组元素。指针变量名++ 指针变量名-- 也可以通过指针变量名加减来访问数组元素。
示例：
int arr[5] = { 1,2,3,4,5 };
int *p = arr; //指针指向数组的第一个元素，即指针p的值为arr[0]的地址
cout << *p << endl; //输出数组的第一个元素
p++; //指针指向数组的第二个元素
cout << *p << endl; //输出数组的第二个元素
指针访问二维数组
二维数组名在大多数情况下可以当作指向一维数组的指针来使用，因此可以通过指针来访问二维数组元素。
示例：
int arr[2][3] = { {1,2,3}, {4,5,6} };
int (*p)[3] = arr; //指针指向长度为3的数组，即指针p的值为arr[0]的地址 int (*p)和int *p是一样的，只是(*p)表示指向一个数组，优先表明为指针而不是数组	
cout << *(*p + 1) << endl; //输出二维数组的第二个元素
p++; //指针指向二维数组的第二个元素
cout << *(*p + 2) << endl; //输出二维数组的第三个元素
7.7 指针与函数
作用：利用指针作为函数参数，修改实参的值。
示例：
void swap(int *p1, int *p2) {
	int temp = *p1;
	*p1 = *p2;
	*p2 = temp;
}
int main() {
	int a = 10;
	int b = 20;
	swap(&a, &b); //通过指针修改实参的值
	cout << "a = " << a << endl; //输出a的值为20
	cout << "b = " << b << endl; //输出b的值为10
	return 0;
}
7.8 冒泡排序和函数和指针案例
案例：
#include <iostream>
using namespace std;

//冒泡排序 参数一：数组首地址 参数二：数组长度  此处arr为指针名不要混淆！！！
void bubbleSort(int *arr, int len) {
	for (int i = 0; i < len - 1; i++) {
		for (int j = 0; j < len - 1 - i; j++) {
			if (arr[j] > arr[j + 1]) {
				int temp = arr[j];
	           arr[j] = arr[j + 1];
	           arr[j + 1] = temp;
			}
		}
	}
}

int printArraay(int *arr, int len) {
	for (int i = 0; i < len; i++) {
		cout << arr[i] << " ";
	}
	cout << endl;
	return 0;
}

int main() {
	int arr[] = { 5,4,3,2,1 }; //创建数组
	int len = sizeof(arr) / sizeof(arr[0]); //计算数组长度
	bubbleSort(arr, len); //调用冒泡排序函数 传入数组首地址和数组长度
	printArraay(arr, len); //打印排序后的数组
	
	return 0;
}

8 结构体
8.1 结构体基本概念
结构体是一种自定义的数据类型，可以包含多个不同类型的数据成员。
自定义数据类型就是内置数据类型的集合
使用string输出时需要包含头文件#include<string>

8.2 结构体定义和使用
结构体定义语法：struct 结构体名 { 数据成员列表 };
通过给结构体定义变量的方法有三种：
struct 结构体名 变量名 ; 示例代码：struct Student stu1;
struct 结构体名 变量名 = { 成员1的值, 成员2的值, ... }; 示例：struct Student stu2 = { 18, "Tom" };
struct 结构体名 { 数据成员列表 } 变量名; //定义结构体时顺便定义变量,示例：struct Student { int age; string name; } stu3;
使用：
结构体变量的使用语法：结构体变量名.成员名; 通过.来访问结构体中的成员
结构体变量定义语法：结构体名 变量名; 
结构体变量的使用语法：变量名.成员名;
结构体指针的使用语法：指针变量名->成员名;

8.3 结构体数组
结构体数组是包含多个结构体变量的数组。
定义语法：struct 结构体名 数组名[数组长度] = { {}, {}, ... {} }; 
使用语法：数组名[下标].成员名;
一维数组(以此类推)示例：
#include <iostream>

struct liang {
	int a;
 int b;

};
                    //{1表示a的值，9表示b的值}
struct liang arr[5] = { {1,9}, {2,8}, {3,7}, {4,6}, {5,5} };

int main() {

 
 std::cout<<arr[2].b;

 struct liang  c;



	 
    system("pause");
	return 0;
}
8.4 结构体指针
结构体指针是指向结构体变量的指针。通过指针访问结构体成员时，需要使用->运算符。
定义语法：struct 结构体名 *指针变量名;
使用语法：指针变量名->成员名;
示例：
struct liang {
	int a;
    int b;
	float c;

}; //自定义一个结构体


int main() {

 liang a = {1,2,3.5}; //创建一个结构体变量
 liang *p = &a; //创建一个指向结构体变量的指针
 
    std::cout << p->b << std::endl; //通过指针访问结构体成员


	 
    system("pause");
	return 0;
}
访问一维数组示例：
 liang l1[3] = {
        {1, 2, 3.0},
        {4, 5, 6.0},
        {7, 8, 9.0}
    } ;
	 liang (*p)[3] = &l1;
    std::cout << "l1[0] = " << (*p)[0].c << std::endl;
访问二维数组示例：
liang l1[3][4] ={
 {1,2,3,},
 {5,6,7},
 {9,10,11}
} ;
 liang (*p)[3][4] = &l1;
    std::cout << "l1[0][0] = " << (*p)[0][0].b << std::endl;

8.5 结构体嵌套结构体
作用：结构体成员可以是另一个结构体 例如：每个老师辅导一个学生，学生和老师都是结构体，老师结构体中包含一个学生结构体
定义语法：struct 结构体名 { 数据成员列表; struct 另一个结构体名 变量名; };
使用语法：结构体变量名.另一个结构体变量名.成员名;

8.6 结构体作为函数参数
结构体可以作为函数的参数传递给函数。
传递方式有两种：值传递和指针传递。
值传递：将结构体变量的值复制一份传递给函数，函数内部对结构体变量的修改不会影响到实参的值。
指针传递：将结构体变量的地址传递给函数，函数内部通过指针访问结构体变量，可以修改实参的值。
示例：#include <iostream>

struct liang {
	int a;
    int b;
	float c;

}; //自定义一个结构体

void print(liang l) {
	std::cout << l.a << std::endl;
	std::cout << l.b << std::endl;
	std::cout << l.c << std::endl;
}

void print2(liang *l) {
	std::cout << l->a << std::endl;
	std::cout << l->b << std::endl;
	std::cout << l->c << std::endl;
}

int main() {

 liang a = {1,2,3.5}; //创建一个结构体变量
 print(a); //值传递
 
 print2(&a); //指针传递

    system("pause");
	return 0;
}

8.7 结构体中const的使用场景
作用：用const防止误操作修改结构体成员的值 语法：const 数据类型 成员名;
示例：
#include <iostream>

struct liang {
	int a;
	int b;
	const float c; //用const修饰结构体成员，防止误操作修改结构体成员的值

}; //自定义一个结构体

void print(const liang *l) {
    l->a = 100; //不可以修改，因为指针指向的结构体成员是const
}
int main() {

	liang a = { 1,2,3.5 }; //创建一个结构体变量
	print(&a); //指针传递

	system("pause");
	return 0;
}

C++核心编程
本阶段主要针对C++面向对象编程技术做详细讲解，探讨C++中的核心和精髓
1 内存分区模型
C++在执行程序时，将内存大方向划分为四个部分：
代码区：存放函数体的二进制代码，由操作系统进行管理的
全局区：存放全局变量和静态变量以及常量，程序结束后由操作系统释放
栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收
内存四区意义：
不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程
1.1 程序运行前
在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域
代码区：
存放CPU执行的机器指令
代码区是唯二的两个保存程序数据的内存区域之一
代码区是共享的，共享的目的是对于频繁执行的程序，只需要在内存中有一份代码即可，节省内存空间
代码区是只读的，防止程序意外地修改了机器指令

全局区：存放全局变量和静态变量以及常量，程序结束后由操作系统释放
在函数体中为局部变量分配空间，在栈区分配
在函数体定义外为全局变量分配空间，在全局/静态存储区分配
全局区是唯二的两个保存程序数据的内存区域之一
静态变量：在变量前添加关键字static，称为静态变量
静态变量在程序结束后由操作系统释放
常量：
字符串常量：以空字符结尾的字符数组，被双引号括起来的内容就算是字符串常量
const修饰的变量：coust修饰的全局变量（全局常量），coust修饰的局部变量（局部常量），局部变量不存放在全局区
常量在程序结束后由操作系统释放

1.2程序运行后
栈区：
由编译器自动分配释放，存放函数的参数值，局部变量等
注意事项：
不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

堆区：
由程序员分配释放，若程序员不释放，程序结束时由操作系统回收，
在C++中主要使用new在堆区开辟内存
语法：new 数据类型(初始值)，返回的是16进制内存地址。
示例：
指针本质也是局部变量放在栈区上，指针保存的数据放在堆区
int * fuck()
{
 int * p = new int(10)
return p;

}
//在main中
int *p = fuck()
cout<<*p<<endl;//输出10

1.3 new操作符
C++利用new操作符在堆区开辟数据
堆区开辟的数据，由程序员手动开辟，手动释放，释放使用操作符delete
语法：new 数据类型 示例 int * p = new int(10);
利用new创建的数据会返回该类型的指针
delete 指针变量名;
利用new创建数组：
int *arr = new int[5]; // 创建一个包含5个整数的数组，返回数组首地址
访问语法：指针变量名[下标]。delete[] 指针变量名;

2 引用

引用是C++中一种重要的类型，它为变量提供了一个别名。通过引用，可以使用另一个名字来访问同一个变量。
定义语法：数据类型 &引用名 = 原变量名;
引用需要引用一块合法的内存空间
使用语法：引用名.成员名;
示例：
#include <iostream>

int main() {
	int a = 10;
	int &b = a; // b是a的引用
	b = 20; // 修改b的值，也会修改a的值
	std::cout << a << std::endl; // 输出20
	return 0;
}

2.2 引用的注意事项
引用必须初始化，引用初始化后不能改变
引用作为函数参数，可以简化代码，引用作为函数参数传递时，不会产生副本，可以修改实参的值
引用作为函数的返回值，不要返回局部变量的引用，因为局部变量在函数结束后会被销毁
引用的本质：引用的本质是给变量取了一个别名
错误语法：int &b; // 引用必须初始化
示例：
#include <iostream>

int main() {
	int a = 10;
	int &b = a; // b是a的引用，初始化,引用初始化后不能改变
	b = 20; // 修改b的值，也会修改a的值
	std::cout << a << std::endl; // 输出20
	int c = 30;
	//int &b = c; // 引用初始化后不能改变,报错
	b = c; //这是赋值操作，不是改变引用
	return 0;
}

2.3 引用做函数参数
作用：函数传参时，可以利用引用技术让形参修饰实参
优点：可以简化指针修过实参
语法：返回值类型 函数名(数据类型 &引用名) { 函数体; }
示例：#include <iostream>

void swap(int &a, int &b) {
	int temp = a;
	a = b;
	b = temp;
}

int main() {
	int a = 10;
	int b = 20;
	swap(a, b); // 交换a和b的值
	std::cout << "a = " << a << ", b = " << b << std::endl; // 输出a = 20, b = 10
	return 0;
}

2.4 引用做函数返回值
作用：让引用可以作为函数返回值来使用
注意：不要返回局部变量，不要返回局部变量的引用，如果函数返回值是引用就可以作为函数的返回值
用法：函数调用作为左值 
示例：
*/int & test() {
    static int a = 10; // 静态变量，生命周期为整个程序运行期间
    return a; // 返回静态变量的引用
} 也就是test()是a的别名*/
int& test() {
	static int a = 10; // 静态变量，生命周期为整个程序运行期间
	return a; // 返回静态变量的引用
}

int& test2() {
	int a = 10; // 局部变量，生命周期为函数运行期间
	return a; // 返回局部变量的引用，错误
}

int main() {
	int& ref = test(); // 引用作为函数返回值
	test() = 100; // 修改引用的值，也会修改静态变量的值
	std::cout << test() << std::endl; // 输出100
	int& ref2 = test2(); // 引用作为函数返回值，错误，因为test2()返回的是局部变量的引用
	return 0;
}

2.5 引用的本质
本质：引用的本质在c++内部实现是一个指针变量
int& ret = a; // 相当于 int* const ret = &a; 指针常量，指针指向不可改
ret = 100; // 相当于 *ret = 100; 通过指针修改a的值

2.6 常量引用
作用：常量引用主要用于修饰形参，防止误操作
在函数形参列表中，可以用const修饰形参，防止形参修改实参。
示例：
const int& ref = a; // ref是a的常量引用
ref = 20; // 错误，不能通过常量引用修改a的值
const int& ref = 10; // 常量引用可以引用常量,编译器会将代码转换为int temp = 10; const int& ref = temp;
常量引用的本质：常量引用的本质是一个指向常量的指针

3 函数提高
3.1 函数默认参数
在c++中，函数的形参列表中的形参是可以有默认值的，这些默认值称为函数的默认参数。
语法：返回值类型 函数名 (数据类型 形参名 = 默认值) { 函数体; }
传入数据优先级大于默认值，如果传入数据，则使用传入数据，如果未传入数据，则使用默认值
注意事项：
1.如果某个位置的形参有默认值，那么该位置往后，从左到右的所有形参都必须有默认值
2.如果函数声明中有了默认参数，那么函数实现中就不能再出现默认参数，声明和实现只能一个有默认参数

3.2 函数的占位参数
c++中的形参列表里可以有占位参数，用于占位，调用函数时必须填补该位置
语法：返回值类型 函数名 (数据类型 形参名 , 数据类型) { 函数体; }//单一的数据类型就属于占位参数
占位参数还可以有默认参数，语法：返回值类型 函数名 (数据类型 形参名, 数据类型 = 默认值) { 函数体; }

3.3 函数重载
3.3.1 函数重载概述
作用：函数名可以相同，提高复用性
函数重载满足条件：
1.同一个作用域下
2.函数名相同
3.函数参数类型不同，或者参数个数不同，或者参数顺序不同
注意：函数返回值不可以作为函数重载的条件
示例：
#include <iostream>

// 函数重载
void func() {
	std::cout << "func()调用" << std::endl;
}

void func(int a) {
	std::cout << "func(int a)调用" << std::endl;
}

void func(double a, int b) {
	std::cout << "func(double a, int b)调用" << std::endl;
}
void func(int a, double b) {
	std::cout << "func(int a, double b)调用" << std::endl;
}

3.3.2 函数重载注意事项
注意事项：
1.函数重载与函数返回值无关
2.函数重载与函数参数默认值有关
3.函数重载与函数参数类型转换有关
引用作为函数重载的条件
函数重载遇到默认参数
引用作为函数重载的条件的注意事项：
引用作为函数重载的条件时，引用类型必须不同
示例：
void func(int &a) {
	std::cout << "func(int &a)调用" << std::endl;
}

void func(const int &a) {
	std::cout << "func(const int &a)调用" << std::endl;
}

int main() {
	int a = 10;
	func(a); // 调用func(int &a)
	const int b = 20;
	func(b); // 调用func(const int &a)
	return 0;
}
函数重载遇到默认参数的注意事项：
当函数重载遇到默认参数时，可能会导致调用函数时出现二义性
示例：
void func(int a, double b = 3.14) {
	std::cout << "func(int a, double b = 3.14)调用" << std::endl;
}

void func(int a) {
    std::cout << "func(int a)调用" << std::endl;

}

int main() {
	func(10); // 二义性，编译器不知道调用哪个函数
	return 0;
}

4.类和对象
C++面向对象的三大特性：封装、继承、多态
C++认为万事万物皆对象，对象是类的实例化，对象上有其的属性和行为

类是对一类事物的抽象，是对具有相同属性和行为的事物的描述
例如：
人可以作为对象，人有属性：姓名、年龄、性别等
人有行为：吃饭、睡觉、工作等
车可以作为对象，车有属性：品牌、颜色、价格等
车有行为：启动、行驶、停车等
具有相同属性的对象可以归为一类事物，这类事物就可以用类来描述，人属于人类，车属于汽车类
4.1 封装
封装是面向对象的三大特性之一，是将数据和操作数据的函数绑定在一起，形成一个整体，对外隐藏实现细节，只暴露接口。
封装的作用：
1. 提高代码的复用性
2. 提高代码的可维护性
3. 提高代码的安全性
4.1.1 封装的意义
封装是面向对象的三大特性之一
封装的意义：
将属性和行为绑定在一起，形成一个整体，表现生活的事物
将属性和行为加以权限控制
封装意义一：
在设计类的时候，属性和行为写在一起，表现事物
语法：class 类名 {访问权限: 属性 / 行为 }；
行为一般使用函数来表示
通过类创建对象语法：类名 对象名;
对象赋值语法：对象名.属性名 = 值; 对象名.行为名();
实例化的意思：通过类创建对象的过程称为实例化，创建对象的过程就是类的实例化过程
专业术语解释:类中属性和行为统一称为成员，属性称为成员属性和成员变量，行为称为成员函数和成员方法
示例一：设计一个圆类，求圆的周长
class Circle {
public: //访问权限
	double radius; //属性 半径
	double getCircumference() { //行为 求周长
		return 2 * 3.14 * radius;
	}
};

int main() {
	Circle c;
	c.radius = 10;
	std::cout << "圆的周长为：" << c.getCircumference() << std::endl;
	return 0;
}
封装意义二：
将属性和行为加以权限控制
访问权限有三种：
public 公共权限 ：公共权限的成员可以在类内或者类外直接访问
protected 保护权限 : 保护权限的成员只能在类内和子类中访问 类外无法直接访问
private 私有权限 : 私有权限的成员只能在类内访问，类外无法直接访问 子类不可以直接访问
默认权限：类中成员的默认权限是私有权限
类内是指在类的成员函数中访问
子类是指通过继承方式创建的类
示例：
class Person {
public:
	std::string name; // 公共权限
protected:
	int age; // 保护权限
private:
	std::string password; // 私有权限
public:
	void setPassword() { // 公共权限
		name = "张三";
		age = 18;
		//password = "123456"; // 私有权限，可以在类内访问
	}
};

int main() {
	Person p;
	p.name = "张三"; // 公共权限
	//p.age = 18; // 保护权限，类外无法访问
	//p.password = "123456"; // 私有权限，类外无法访问
	return 0;
}

4.1.2 封装-C++中struct和class的区别
struct和class的区别：
struct默认权限是公共权限 public，class默认权限是私有权限 private
struct主要用于描述数据结构，class主要用于描述具有属性和行为的事物
struct也支持权限控制，可以使用public、protected、private来修饰成员

4.1.3将成员属性设置为私有
优点一：保护成员属性，防止误操作，将所有成员属性设置为私有，可以自己控制读写权限
优点二：对于写权限，我们可以检测数据的有效性，保证数据的有效性
示例代码：
class Person {
private:
	int age; // 私有权限
	int height; // 私有权限只写
	int weight = 80; // 私有权限只读
public:
	void setAge(int a) { // 写权限
		if (a < 0 || a > 150) {
			std::cout << "年龄输入有误！" << std::endl;
			return;
		}
		// 数据有效性检测，避免输入无效数据
		age = a;
	}

	int getAge() { // 读权限
		return age;
	}
	void setHeight(int h) { // 写权限
		if (h < 0 || h > 300) {
			std::cout << "身高输入有误！" << std::endl;
			return;
		}
		// 数据有效性检测，避免输入无效数据
		height = h;
	}
	int getWeight() { // 读权限
		return weight;
	}
};

4.2 对象的初始化和清理
在我们生活中电子产品大多数都有出厂设置，在某一天我们不用了需要删除隐私数据可以恢复出厂设置
C++中类的对象也有类似的机制，称为构造函数和析构函数

4.2.1 构造函数和析构函数
对象的初始化和清理是两个很重要的安全问题
一个对象或者变量没有初始状态，很可能会导致程序出现不可预知的错误
同样使用完一个对象和变量没有及时清理，也会导致一定的安全问题。

C++中提供了两种特殊的成员函数来解决对象的初始化和清理问题,这两个函数会被编译器自动调用，完成对象初始化和清理工作。
对象初始化和清理工作是编译器强制要我们做的事情，如果我们不提供这两个函数，编译器会自动提供默认的构造函数和析构函数默认为空实现。

构造函数：用于对象的初始化，在对象创建时自动调用
析构函数：用于对象的清理，在对象销毁时自动调用

构造函数语法：
类名(){};
示例1：
类名(){
	std::cout << "构造函数调用" << std::endl;
}
1.构造函数没有返回值也不写void;
2.构造函数名必须与类名相同，区分大小写；
3.构造函数可以有参数，也可以没有参数；可以重载
4.程序在调用对象时会自动调用构造函数，无需手动调用并且只调用一次；方法和常规函数一样

析构函数语法：
~类名(){};
1.析构函数没有返回值也不写void;
2.析构函数名必须与类名相同，前面加上波浪号~，区分大小写；
3.析构函数不能有参数，也不能重载；
4.程序在对象销毁时会自动调用析构函数，无需手动调用并且只调用一次；

构造和析构函数是必须要的；

4.2.2 构造函数的分类以及调用
两种分类方式：
按参数分类：无参构造函数、有参构造函数 无参构造也被称为默认构造函数
按类型分类：普通构造函数、拷贝构造函数
三种调用方法：
括号法；直接调用 
示例：
void te01(){
Person p1 ;//默认构造函数调用,无参构造函数调用
Person p2(10); //有参构造函数调用
Person p3(p2); //拷贝构造函数调用
cout<<p2.age;
cout<<p3.age;
//p2，p3输出一样为10，因为p3是p2的拷贝，调用拷贝函数的使用意思是：将传入的对象属性全部赋值给当前对象，例如p2赋值给p3;
}
注意事项：
调用默认构造函数时不要加小括号()，编译器会把它被当做函数声明；

显示法；显示调用
void te02(){
	Person p1; //默认构造函数调用
	Person p2 = Person(10); //有参构造函数调用，相当于创建了一个匿名对象然后赋值给p2
	Person p3 = Person(p2); //拷贝构造函数调用，相当于创建了一个匿名对象然后赋值给p3
	Person(10);//匿名对象 特点，当前行执行结束，系统会立即回收匿名对象所占用的内存；
	//注意事项2，不要利用拷贝函数初始化匿名对象，否则会报错； Person(p2);编译器会认为是Person(p2) == Person p2;
}


隐式转换法；隐式调用
void (){
	Person p1 = 10; //有参构造函数调用，等价于Person p1 = Person(10);
	Person p2 = p1; //拷贝构造函数调用，等价于Person p2 = Person(p1);
}

拷贝构造函数的写法：类名 (const 类名 &引用名) {}; 将所有属性拷贝到当前对象,调用拷贝函数的使用意思是：将传入的对象属性全部赋值给当前对象，例如p2赋值给p3;
类名 对象(另一个对象名); //调用拷贝构造函数赋值给当前对象
示例：
#include <iostream>
class Person {
Person(const Person &p) { // 拷贝构造函数
		age = p.age;
	}
	int age;
}
除了拷贝函数其他都是普通构造函数

4.2.3 拷贝函数的调用时机
C++中拷贝函数的调用时机有三种：
1.利用一个已经创建好的对象来初始化一个新对象
Person p2 = p1; // 调用拷贝构造函数

2.函数传值参数调用，值传递的方式给函数参数传递值
void func(Person p) { // 调用拷贝构造函数
	// 函数体
}
Person p1;
func(p1); // 传值调用，调用拷贝构造函数

3.函数返回值为对象类型，以值传递的方式返回局部对象
Person func() {
	Person p; // 创建一个对象
	return p; // 返回对象，调用拷贝构造函数
}

4.2.4 构造函数调用规则
默认情况下C++编译器至少要为一个类添加三个函数
1.默认构造函数（无参，函数体为空）
2.默认析构函数（无参，函数体为空）
3.默认拷贝函数，对属性进行值拷贝 //值拷贝的意思为，将被拷贝的对象所以属性赋值给当前对象

构造函数的调用函数规则如下：
如果用户定义有参构造函数，C++不再提供默认无参构造函数，但是会提供默认拷贝构造
如果用户定义有拷贝构造函数，C++不会提供其他构造函数。

4.2.5 深拷贝与浅拷贝
深浅拷贝是面试经典问题，也是常见的一个坑

浅拷贝：简单的赋值拷贝。一般为编译器的默认拷贝构造，会导致一个问题堆区内存被重复释放，需要使用深拷贝解决
深拷贝：在堆区重新申请空值，进行拷贝操作

析构函数的使用时机一般为，结束堆区创建的数据。

深浅拷贝的示例代码如下：
浅拷贝：
preo(const preo &p){

	m_age = m_age;
	m_hiede = m_hiede;//该数据为十六进制堆区数据
}
深拷贝：
preo(const preo &p){

	m_age = m_age;
	//m_hiede = m_hiede;//该数据为十六进制堆区数据
	m_hiede = new int(*p.m_hiede);//重新创建一块新的堆区内存。
}
完整示例代码：
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int age ,int height) {
		
		cout << "有参构造函数!" << endl;

		m_age = age;
		m_height = new int(height);
		
	}
	//拷贝构造函数  
	Person(const Person& p) {
		cout << "拷贝构造函数!" << endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		m_age = p.m_age;
		m_height = new int(*p.m_height);
		
	}

	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
		if (m_height != NULL)
		{
			delete m_height;
		}
	}
public:
	int m_age;
	int* m_height;
};

void test01()
{
	Person p1(18, 180);

	Person p2(p1);

	cout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;

	cout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

> 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题

解惑：创建类的对象需要在类外函数创建对象，在类中创建关于自己的对象会报错，例如：
class pero(){
pulib:
pero re();//错误

}
void te (){
	类名 对象名;
}

4.2.6 初始化列表
作用：C++提供了初始化列表的语法，用于初始化属性
语法：构造函数():属性一(值一)属性二(值二)...{}
示例：
class pero {
	pero (int a ,int b)c(b)d(a){
	cout<<"c:"<<c<<"d"<<d<<endl;
}
}
在上方的c(b)可以理解为pero c = b;
4.2.7 类对象作为类成员
C++类中成员可以是另一个类的对象，我们称该成员为对象成员
例如：
class A{};
class B{
	A.a
};
B类中有对象A作为成员，A为对象成员

当其他类的对象作为本类成员时，构造函数会先构造其他类的对象，再构造本类，析构函数则与构造相反

4.2.8 静态成员
静态成员就是在成员变量和成员函数加上关键字static,称为静态成员

静态成员分为：

静态成员变量
所有对象共享一份数据
在编译器阶段分配内存
类内声明，类外初始化
静态成员变量不属于某个对象上，所有对象都共享同一份数据
静态成员变量也可以用权限控制
因此访问静态成员对象有两种访问方式
1.通过对象进行访问
2.通过类名进行访问
示例：
class pero {
	public:
static int M_a;


}

int pero::M_a = 100;

void p1 (){

	pero p;
	
}

静态成员函数
所有对象共享一个函数
静态成员函数只能访问静态成员函数
1.通过对象进行访问
2.通过类名进行访问
也可以用权限控制

4.3 C++对象和this指针

4.3.1 成员变量和成员函数分别存储
在C++中类内成员变量和成员函数分别存储
只有在非静态成员变量才属于类的对象上
空对象占用为1字节，因为编译器会给每个对象都分配1字节空间，是为了区分空对象占用内存空间位置。
当类中存在只存在一个非静态int对象它只占用4字节因为它属于这个对象上
添加静态变量int时，只占用4字节因为静态成员变量不属于某个对象上，当继续添加非静态成员函数和静态成员函数，还是4字节因为它们不属于某个对象上

4.3.2 this指针概述
通过4.3.1我们知道在C++成员变量和成员函数是分开存储的
每一个非静态成员函数只会诞生一份函数实例，也就是多个同类型对象会共用一块代码
问题来了，那么这一块代码是怎么知道是哪个对象发起的调用呢？
C++通过提供特殊的对象指针，this指针，解决上述问题，this指针指向被调用的成员函数所属的对象

this指针是隐含每一个非静态成员函数的一种指针
this指针不需要定义，直接使用即可
this指针本质是一个指针常量，指向当前对象 指向不可修改但是this指针的值可以修改
相当于：类名 * const this;
如果想值也不被修改就像这样：const 类名 * const this;
this指针的用途：
当形参和成员变量同名时，可以通过this指针区分
在类的非静态成员函数中返回对象本身，可以使用retuen *this;
示例：
class pero {
public:
	void setAge(int age) {
		this->age = age; // 通过this指针区分成员变量和形参
	}
	int getAge() {
		return this->age; // 通过this指针访问成员变量
	}
	pero& setHeight(int height) {
		this->height = height;
		return *this; // 返回对象本身
	}
private:
	int age;
	int height;
};

返回对象本身这种思维称为链式编程，链式编程就是通过返回对象本身，可以连续，调用对象的多个成员函数，主要为连续调用
使用值返回的方式会创建一个新对象，浪费内存空间，一般使用引用，返回对象本身
示例：
pero p;
p.setAge(18).setHeight(180); // 链式编程

4.3.3 空指针访问成员函数
空指针访问成员函数是允许的
因为成员函数调用时会隐含传递一个this指针，this指针指向调用该成员函数的对象
当通过空指针调用成员函数时，this指针为NULL会出现报错，需要进行预防，报错原因为无法指向对象因为对象为空
在C++中使用空指针也是可以调用成员函数的，但是也要注意有没有用到tsis指针
如果用到tsis指针需要判断代码健壮性,在类中出现一个成员变量，在成员函数使用到这个成员变量时，默认为this->变量名，示例

class prote (){
	
	pubilc:
	void show(){
		std::cout<<"show函数调用"<<std::endl;
	}
	void show_age(){
		std::cout<<"年龄为："<<m_age<<std::endl;//默认为std::cout<<"年龄为："<<this->m_age<<std::endl;
	}
	
	
	int m_age;
	}
	void tses01(){
		pero *p = NULL;
		p->show(); // 可以调用成员函数，不涉及到成员变量
		//p->show_age(); // 不可以调用成员函数，因为show_age使用了this指针访问成员变量，报错原因是this指针为空无法指向对象

	}

示例:
class pero {
public:
	void show() {
		std::cout << "show函数调用" << std::endl;
	}
	void setAge(int age) {
		if (this == NULL) {
			std::cout << "空指针不能访问成员变量" << std::endl;
			return;
		}
		this->age = age;
	}
private:
	int age;
};

void test01() {
	pero* p = NULL;
	p->show(); // 可以调用成员函数，不涉及到成员变量
	p->setAge(18); // 不可以调用成员函数，因为setAge使用了this指针访问成员变量，报错原因是this指针为空无法指向对象
}
4.3.4 const修饰成员函数
作用：在类的成员函数后加上const关键字，称为常量成员函数
语法：返回值类型 函数名() const { 函数体; }
常函数：
成员函数后加上const关键字，称为常量成员函数
常函数只能访问类中的常量成员变量和常量成员函数
常函数可以修饰常对象
常函数内不可修改成员属性
成员属性声明时添加mutable关键字，可以在常函数内修改该成员属性，在常对象下也可以修改
常对象：
通过const关键字修饰的对象，称为常对象
常对象只能调用常函数
常对象不可调用普通成员函数是因为普通成员函数有可能会修改成员属性
示例：
class pero {
public:
	void show() const { // 常量成员函数
		age = 20; 
		std::cout << "年龄为：" << age << std::endl;
	}
	void setAge(int age) {
		this->age = age;
	}

	void setHeight(int height) const {
		this->height = height; // 错误，常函数内不可修改成员属性 相当于const pero * const this;限定指向值不可修改
		//在成员函数后加const，修饰的是this指向，让其指向的值不可修改
	}
private:
	 mutable int age;//添加mutable关键字，可以在常函数内修改该成员属性
	int height;
};
void test01() {
	const pero p; // 常对象
	p.show(); // 可以调用常函数
	//p.setAge(18); // 错误，常对象不能调用非常函数
}

4.4 友元
4.4.1 友元概述
在C++中，类的成员属性一般都是私有的，外部无法直接访问
有时候需要让某个函数或者类访问另一个类的私有成员，这时就需要用到友元
友元可以是函数，也可以是类
友元函数：通过在类中声明一个函数为友元函数，可以让该函数访问类的私有成员
友元类：通过在类中声明另一个类为友元类，可以让该类的所有成员函数访问本类的私有成员

生活中你的家有客厅，卧室，厨房等房间，每个房间都有自己的隐私
有时候你需要让你的好朋友进入你的卧室，这时你就需要给他一把钥匙
友元函数和友元类就像是钥匙，可以让外部函数或者类访问类的私有成员
在程序中，有一些私有属性也想让类外的特殊的函数或者类进行访问就需要用到友元技术
友元的目的就是为了让一个函数或类访问另一个类的私有成员

友元的关键字是friend
友元函数语法：在类中声明friend 返回值类型 函数名(参数列表);
友元类语法：在类中声明friend class 类名;

友元的三种实现：
全局函数做友元
类的成员函数做友元
类做友元

4.4.1 全局函数做友元
通过在类中声明一个全局函数为友元函数，可以让该函数访问类的私有成员
语法：在类中声明friend 返回值类型 函数名(参数列表); 相当于声明该函数可以访问类的私有成员
示例：
#include <iostream>
class Person {
private:
	std::string name;
	int age;
public:
	Person(std::string n, int a) :name(n), age(a) {}
	friend void showPerson(Person p); // 声明友元函数
};
void showPerson(Person p) { // 友元函数定义
	std::cout << "姓名：" << p.name << ", 年龄：" << p.age << std::endl; // 访问私有成员
}
int main() {
	Person p("张三", 18);
	showPerson(p); // 调用友元函数
	return 0;
}

4.4.2 类做友元
通过在类中声明另一个类为友元类，可以让该类的所有成员函数访问本类的私有成员
语法：在类中声明friend class 类名; 相当于声明该类的所有成员函数可以访问本类的私有成员
示例：
#include <iostream>
class Friend; // 前置声明,避免编译错误
class Person {
private:
	std::string name;
	int age;
public:
	Person(std::string n, int a) :name(n), age(a) {}
	friend class Friend; // 声明友元类
};
class Friend {
public:
	void showPerson(Person p) { // 友元类的成员函数
		std::cout << "姓名：" << p.name << ", 年龄：" << p.age << std::endl; // 访问私有成员
	}
};

类外写成员函数的方法：
例如现在有一个类A，我们想在类外实现它的成员函数func，可以按照以下步骤进行：
1. 在类A的声明中，先进行前置声明，告诉编译器类A的存在。
2. 在类A的声明中，声明成员函数func的原型。
3. 在类外实现成员函数func，使用类名加作用域运算符::来定义函数体。
示例代码如下：
#include <iostream>
class A; // 前置声明
class A {
public:
	void func(); // 成员函数声明
};
void A::func() { // 成员函数定义
	std::cout << "类A的成员函数func被调用" << std::endl;
}

4.4.3 成员函数做友元
通过在类中声明另一个类的成员函数为友元函数，可以让该成员函数访问本类的私有成员
语法：在类中声明friend 返回值类型 类名::函数名(参数列表);
示例：
#include <iostream>
class Person; // 前置声明
class Friend {
public:
	void showPerson(Person p); // 成员函数声明
};
class Person {
private:
	std::string name;
	int age;
public:
	Person(std::string n, int a) :name(n), age(a) {}
	friend void Friend::showPerson(Person p); // 声明成员函数为友元
};
void Friend::showPerson(Person p) { // 友元成员函数定义
	std::cout << "姓名：" << p.name << ", 年龄：" << p.age << std::endl; // 访问私有成员
}
int main() {
	Person p("张三", 18);
	Friend f;
	f.showPerson(p); // 调用友元成员函数
	return 0;
}

